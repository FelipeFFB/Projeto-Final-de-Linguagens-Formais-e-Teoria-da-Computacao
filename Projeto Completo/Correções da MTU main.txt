===================================== Dificuldades encontradas e soluções aplicadas =====================================

q1a1a1Rq1#q1bbLqf$a1a1a1 - Deu erro com essa entrada para a MTU na parte "q1bbLqf". A fita ficou q1a1a1Rq1#qZbbLqf$a1a1a1BqZ, mas chegou um momento, quando a máquina estava no estado Move, que ela começou a ir para a direita indefinidamente, nos espaços em branco da MTU. Corrigido adicionado duas transições no bloco Move, uma de q2 para q2 (enquanto não encontrar B, mantém o que está e move para a direita: !B; ~, R) e outra de q2 para q6 (quando achar um B, coloca b e move para a esquerda: B; b, L).

Outro problema encontrado foi que a máquina não verifica uma transição da MT que ela já passou, o que gera erro em alguns casos, como por exemplo no caso q1a1a11Sq1#q1a11a1Sq1$a1 (é pra gerar um loop infinito), em que a MTU não está voltando para verificar a primeira transição da MT e ao invés disso, a MTU está interpretando como se a MT estivesse rejeitando a entrada "a1". Corrigido adicionando um estado intermetidário q23 entre MudaQ e CompQ, com a transição "q;q,L" de MudaQ para q23, a transição "! ; ~, L" de q23 para q23 e a transição " ; , R" de q23 para CompQ. Com esse novo estado e essas novas transições, a MTU sempre volta pro início da fita dela e checa todas as transições, buscando a transição correspondente.

Precisamos tratar o caso em que a MT quer que o cabeçote vá para o começo da fita dela, como no caso q1a1a1Rq1#q1ba1Lq11#q11a1a1Lq11#q11ssRqf$a1a1, em que a MT coloca um a1 no final dessa fita de entrada, depois anda para a esquerda até chegar no início da fita e depois para aceitando. Acho que consegui corrigir esse caso, verificando se quando estava no primeiro elemento e a MT mandava ir para a esquerda, existia uma transição do tipo "q1ssRqf" (o q1 pode ser qualquer outro q, menos o qf. O "qf" do final pode ser qualquer estado também), já que se existir, quando isso acontecer, o cabeçote volta pra primeira posição válida da fita da MT interpretada, caso contrário, a entrada é rejeitada pela MT e a MTU para aceitando (Essas alterações foram feitas tanto dentro do estado Move quanto na MTU). |||||||||||||||||| EDITAR: precisa corrigir o bloco Acha_s para ver se o estado atual tem transição do tipo, por exemplo, se estamos no estado q1 quando chegamos no "s", temos que verificar se o estado q1 tem a transição q1ssRqf. Caso tenha está certo, caso contrário, rejeita. Do jeito que está, essa transição pode ser de qualquer estado, o que está errado. |||||||||||||||||||||||||||||||||||||||||||||| OBS: Quando tivermos uma entrada do tipo q1a1a1Lq11#q11ssRqf$a1, quando fizermos a transição q1a1a1Lq11 (que vai ir pro "$"), temos mudar o estado atual para q11 e depois verificar se o estado q11 tem uma transição do tipo q11ssRq& (& representa "f" ou qualquer quantidade de "1"s). EDIÇÃO FEITA COM SUCESSO! AGORA PARECE QUE A MTU ESTÁ FAZENDO TUDO CERTINHO.

Está dando problema quando está indo de um estado maior para um estado menor, por exemplo, de q11 para q1, por exemplo, na entrada q1a1a1Rq11#q11a1a1Lq1$a1a1 (é pra ficar num loop infinito). (Demorei um pouco pra anotar essa correção, então posso estar falando um pouco errad como corrigi). Acho que consegui corrigir tirando a transição "$; $, S" de MudaQ para q5 e colocando essa transição do estado MudaQ para o estado q23.

Precisamos fazer alterações para conseguir substituir "a"s por "b"s, por exemplo, se tivermos q1a1a1Rq1#q1a11a11Rq1#q1bbLq11#q11a1bLq11#q11a11bLq11#q11ssRqf$a1a11a1, queremos que no final fique, por exemplo, q1a1a1Rq1#q1a11a11Rq1#q1bbLq11#q11a1bLq11#q11a11bLq11#q11ssRqf$bbb#A. Acho que não temos nenhum bloco que faz isso, então, ou alteramos algum bloco, ou criamos um novo bloco para cuidar desse caso e depois o integramos na MTU. Corrigido criando um novo bloco chamada TrocaAPorB, que troca qualquer "a" (a1, a11, a111, ...) por "B" (porque o cabeçote continua no mesmo lugar, já que ele ainda não foi movimentado), e copia toda a fita à direita do último "1" do "a" substituído, para a direita de "B", ocupando o espaço que ficaria vazio.

Precisamos fazer alterações para substituir "a"s por "a"s menores, como por exemplo, se tivermos q1a111a1Sqf$a111, queremos que a saída seja q1a111a1Sqf$a1#A. Não temos um bloco que faz isso ainda, então, ou alteramos algum bloco, ou criamos um novo bloco para cuidar desse caso e depois o integramos na MTU. Corrigido criando alterando como o bloco CompAS funciona, para o caso de precisar remover mais de um "1". Além disso, criei um novo bloco chamado Sub1Novo, que verifica quantos "1"s precisam ser removidos. Se for tirar somente um "1", como por exemplo de a111 para a11, usa o bloco Sub1 antigo, se for 2 ou mais "1"s, como por exemplo, de a111 para a1, ele marca os "X" com "M", depois usa o novo bloco DiminuiA (que é uma adaptação do TrocaAPorB, para aproveitar a parte de copiar tudo o que está à direita do local da substituição para a esquerda (por exemplo, no caso de (...)a111a11qz para (...)a1a11qz, ficaremos com (...)A1MMa11qz antes de entrar no bloco DiminuiA, que então vai copiar tudo à direita do último M para substituir os "M"s, ficando no fim com (...)A1a11qz). Dessa forma, conseguimos substituir qualquer "a" por outro "a" menor no lugar corretamente.

Encontrei alguns problemas quando mudava para estados menores, por exemplo, de q111 para q1. Corrigi fazendo alterações no bloco MudaQ, para desmarcar todos os "Z"s, marcar os "1"s no final da fita como "Z"s, para que o bloco CompQ funcionasse corretamente.

Encontrei problemas quando a fita de entrada da MTU começava com transições da MT do tipo q1ssRq11, porque o bloco CompQ não tinha transição quando o elemento lido depois do bloco ser executado era "s". Corrigi isso adicionando quatro estados na Main para "pular" essa transição quando ela fosse lida no momento errado (por exemplo no início da execução, pq o "s" só serve para marcar o início da fita, já que a MT é limitada à esquerda, mas o cabeçote da MT interpretada começa no primeiro elemento depois de "s"(que representa o "$").

Corrigi os casos em que a MT chegava no "s", procurando se havia uma transição no estado atual do tipo "(...)ssR(...)". Se houvesse, era uma transição válida, caso contrário não. Esses casos do "s" foram tratados criando o bloco Acha_s (que é composto pelos blocos CompQ e pelo bloco MudaQ, além de outros estados), que compõe o bloco Move, para tratar dos casos em que a MT tem transições que tentam ir para a esquerda quando já está no início da fita, como por exemplo, no caso "q1a1a1Lq1$a1".